I am so happy with this problem!

Thought process:\
1. First thought this has a greedy algorithm which proven wrong.\
2. Then I tried DFS which searches all possible path with some optimization(only tries closest positions forward and backword).
   However it's really slow, even though I tried to use memorization a little.\
3. I thought for long time and still don't see any way to improve the DFS solution.\
4. One of the tags of this problem is dynamic programming which I thought for long time but can't find a simple dp conversion.\
5. Then I thought maybe it's one of those m * n dp problem.\
6. One of the other benefit of trying all possible next positions is the shortest point from i to j is very easy to calc.\
7. So I wrote it out which is proven to be a lot faster.

This is one of the few times I could actually find a better solution which is different from original thought.\
It's really hard to think of a problem from a different perspective.\
But this time I really learned a lot from the whole process.
