Problems worth revisiting:\
4
5
10
11
15
22
25
28
30
31
33
34
37
44
48
55
68
69
71
72
75
81
92
98
99
111
117
122
128
145
148
153
154
155
161
162
168
179
188
198
207
208
212
215
220
221
222
238
239
240
259
260
261
269
275
277
281
282 dfs, no great solution
287
296
300
301
307 segment tree, able to do it myself
308 2d binary indexed tree
310 
314
315 binary search tree
316 correct idea but not as fast
322 performance between vector and unordered_map is huge
324 really hard to understand 
326 not much, a little tricky
327 segment tree or merge sort solution
336 find rest of string instead of concat
337 point is how to define the problem
341 there's better solution than using pair of iterator
347 easy but need to think in a different way
348 easy O(n) but can keep count in each row/col(use 1 for p1 and -1 for p2)
358 seemingly dumb algo but actually works
374 bit oper, keep shifting the and result to left until it's 0
377 medium, thought for a while
378 merge n sorted arrays or binary search
380 very brilliant solution
394 tricky to get right
395 thought for a bit, divide and conquer
399 dfs
402 was able to do it but learned sol is better
407 priority queue solution is hard to think of
410 dp is slow, binary search is a great idea
416 knapsack problem
426 my sol is too complex
430 not difficult, but hard to get it all correct
432 hard to think of the data structure
435 interval scheduling
437 record accumulative sum, not all possible sum values
440 treat is like a tree, but quite hard to understand
445 easy, but can use a stack
446 actually not too hard
448 easy but there's a great way to do it
450 hard to find a elegant recursive sol
478 math prob
491 smart way to avoid using set 
